bindkey -e

# Path to your oh-my-zsh configuration.
ZSH=$HOME/.oh-my-zsh

# Path to zsh customizations
export ZSH_CUSTOM=$HOME/.oh-my-zsh-custom

# Set to this to use case-sensitive completion
# CASE_SENSITIVE="true"

# Comment this out to disable bi-weekly auto-update checks
# DISABLE_AUTO_UPDATE="true"

# Uncomment to change how many often would you like to wait before auto-updates occur? (in days)
# export UPDATE_ZSH_DAYS=13

# Uncomment to disable ZSH auto correction for commands (correct) and command arguments (correct_all)
# unsetopt correct
# unsetopt correct_all

# Uncomment following line if you want to disable colors in ls
# DISABLE_LS_COLORS="true"

# Uncomment following line if you want to disable autosetting terminal title.
# DISABLE_AUTO_TITLE="true"

# Uncomment following line if you want red dots to be displayed while waiting for completion
export COMPLETION_WAITING_DOTS="true"

# Automatically quote globs in URL and remote references
# http://superuser.com/questions/420525/scp-with-zsh-no-matches-found
__remote_commands=(scp rsync)
autoload -U url-quote-magic
zle -N self-insert url-quote-magic
zstyle -e :urlglobber url-other-schema '[[ $__remote_commands[(i)$words[1]] -le ${#__remote_commands} ]] && reply=("*") || reply=(http https ftp)'

# Which plugins would you like to load? (plugins can be found in ~/.oh-my-zsh/plugins/*)
# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
#plugins=(java alm appsdk bundler git)
plugins=(alias-tips colored-man common-aliases docker osx)

if [ -e "$ZSH/oh-my-zsh.sh" ]; then
  source "$ZSH"/oh-my-zsh.sh
fi

unsetopt share_history

# Customize to your needs...
if which rbenv > /dev/null; then eval "$(rbenv init -)"; fi

fpath=(/usr/local/share/zsh-completions $fpath)

export EDITOR=nvim
export VISUAL=nvim

export GOPATH=$HOME/projects
export PATH=$PATH:$GOPATH/bin
unset LSCOLORS

if [ -e /usr/local/share/zsh/site-functions/_aws ]; then
  source /usr/local/share/zsh/site-functions/_aws
fi

awesome() {
 echo "DAMN RHYTE YOU ARE AWESOME"
}

# modified 'kolo' color scheme
autoload -U colors && colors

autoload -Uz vcs_info

zstyle ':vcs_info:*' stagedstr '%F{green}●'
zstyle ':vcs_info:*' unstagedstr '%F{yellow}●'
zstyle ':vcs_info:*' check-for-changes true
zstyle ':vcs_info:(sv[nk]|bzr):*' branchformat '%b%F{1}:%F{11}%r'
zstyle ':vcs_info:*' enable git svn

theme_precmd () {
  if [[ -z $(git ls-files --other --exclude-standard 2> /dev/null) ]] {
      zstyle ':vcs_info:*' formats ' %b%c%u%B%F{green}'
  } else {
      zstyle ':vcs_info:*' formats ' %b%c%u%B%F{red}●%F{green}'
  }

  vcs_info
}

start_time=$SECONDS
function prompt_paradox_preexec {
  start_time=$SECONDS
}

time_precmd () {
  timer_result=$(($SECONDS-$start_time))
  if [[ $timer_result -gt 5 ]]; then
    calc_elapsed_time
  else
    unset timer_result
  fi
  start_time=$SECONDS
}

calc_elapsed_time () {
  if [[ $timer_result -ge 3600 ]]; then
    let "timer_hours = $timer_result / 3600"
    let "remainder = $timer_result % 3600"
    let "timer_minutes = $remainder / 60"
    let "timer_seconds = $remainder % 60"
    timer_result="${timer_hours}h${timer_minutes}m${timer_seconds}s"
  elif [[ $timer_result -ge 60 ]]; then
    let "timer_minutes = $timer_result / 60"
    let "timer_seconds = $timer_result % 60"
    timer_result="${timer_minutes}m${timer_seconds}s"
  else
    timer_result="${timer_result}s"
  fi
}

setopt prompt_subst
PROMPT='%F{cyan}${timer_result} %{$fg_bold[blue]%}%c%{$reset_color%}%B%F{green}${vcs_info_msg_0_}%B%F{magenta} %{$reset_color%}%% '

autoload -U add-zsh-hook
add-zsh-hook precmd  theme_precmd
add-zsh-hook precmd  time_precmd

cl ()
{
  awk -v col=$1 '{print $col}'
}

idunno()
{
  echo -n "¯\_(ツ)_/¯" | pbcopy
  echo "¯\_(ツ)_/¯"
}

fixaudio ()
{
   sudo pkill -i coreaudio
   sudo pkill -i spotify
}

fixvolume ()
{
  osascript -e "set volume input volume 100"
}

reked ()
{
  docker ps --filter status=exited --quiet | xargs docker rm -f
}

riked ()
{
  docker images | grep none | awk {'print $3'} | xargs docker rmi
}

wtf () {
  cat << EOF
(ノ ゜Д゜)ノ ︵ ┻━┻
CTRL + Q - binding for tmux
CTRL + U – Cuts text up until the cursor
CTRL + K – Cuts text from the cursor until the end of the line
CTRL + Y – Pastes text
CTRL + E – Move cursor to end of line
CTRL + A – Move cursor to the beginning of the line
ALT + F – Jump forward to next space
ALT + B – Skip back to previous space
ALT + Backspace – Delete previous word
CTRL + W – Cut word behind cursor
EOF
}

notify () {
  pusher -i 2093 DONE
}

if [ -e ~/.waffle.env ]; then
  source ~/.waffle.env
fi

# GPG Agent stuffs
# https://gist.github.com/bmhatfield/cc21ec0a3a2df963bffa3c1f884b676b
if [ -f ~/.gnupg/.gpg-agent-info ] && [ -n "$(pgrep gpg-agent)" ]; then
  source ~/.gnupg/.gpg-agent-info
  export GPG_AGENT_INFO
else
  eval $(gpg-agent --daemon --write-env-file ~/.gnupg/.gpg-agent-info)
fi

source <(kubectl completion zsh)

# The next line updates PATH for the Google Cloud SDK.
if [ -f '/Users/skajo02/google-cloud-sdk/path.zsh.inc' ]; then source '/Users/skajo02/google-cloud-sdk/path.zsh.inc'; fi

# The next line enables shell command completion for gcloud.
if [ -f '/Users/skajo02/google-cloud-sdk/completion.zsh.inc' ]; then source '/Users/skajo02/google-cloud-sdk/completion.zsh.inc'; fi

fuckincpuhog () {
  output=$(ps -e -o pid,pri,pcpu,comm | grep -i vshield)
  echo ${output}
  process_count=$(ps -e -o pid,comm | grep -i vshield | wc -l)
  echo "Processes Found: ${process_count}"
  ps -e -o pid,comm | grep -i vshield | grep -v grep | awk {'print $1'} | xargs sudo renice 20
  output=$(ps -e -o pid,pri,pcpu,comm | grep -i vshield)
  echo ${output}
}

export NVM_DIR="$HOME/.nvm"
. "/usr/local/opt/nvm/nvm.sh"
